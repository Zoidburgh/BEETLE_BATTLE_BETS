# Beetle Battle Bets: Vibe Coding Development Plan

## Executive Summary

We're building a skill-based betting game where players watch AI beetles fight and profit from pattern recognition. The entire project will be **vibe coded** with AI assistance - no manual asset creation, no traditional game engine, just pure Python + GPU acceleration + AI guidance.

**Timeline:** 6-8 weeks to shippable prototype  
**Platform:** PC (Windows/Linux/Mac) via itch.io  
**Core Innovation:** Real neural networks + GPU physics + procedural everything  
**Development Style:** Rapid iteration with AI, test-play-refine loop

---

## Tech Stack Rationale

### Why This Stack Enables Vibe Coding

**Taichi (Physics + Rendering)**
- Pure Python - AI can read/write it fluently
- GPU acceleration without CUDA knowledge
- Built-in voxel renderer (no Blender, no Unity)
- Particle systems are trivial
- Live reload during development
- Excellent documentation for Claude to reference

**JAX (Neural Networks)**
- JIT compilation makes brains fast
- Vectorization = train 50 beetles in parallel
- Pure functions = easy to reason about
- GPU support out of box
- AI can write/debug JAX easily

**Python Game Layer**
- Familiar to AI coding assistants
- Rapid prototyping
- No compilation step
- Easy to read state/debug

### What AI Will Generate

**Everything:**
- Voxel beetle models (procedural code)
- Physics parameters (tuning through iteration)
- Neural network architectures
- UI layouts and styling
- Particle effects
- Game balance numbers
- Sound synthesis (via libraries)

**Nothing will be hand-made.** If we need a beetle model, we describe it and AI generates the voxel placement code. If physics feels wrong, we describe the issue and AI adjusts parameters.

---

## Beetle Physics Interaction & Animation System

### The Core Challenge

Beetles need to:
1. **Push each other** (physics collision response)
2. **Show visual feedback** (animation reacting to physics state)
3. **Feel impactful** (particles, screen shake, sound)
4. **Look alive** (legs, pincers, body language)

All of this must work with **AI-controlled beetles** and be **procedurally generated by AI code**.

---

### Physics Interaction Layer

**Collision Detection:**

```python
@ti.kernel
def detect_beetle_collisions():
    """GPU-accelerated collision detection between beetles"""
    
    for i, j in ti.ndrange(num_beetles, num_beetles):
        if i < j:  # Don't check same pair twice
            beetle_a = beetles[i]
            beetle_b = beetles[j]
            
            # Simple sphere collision (fast)
            diff = beetle_a.position - beetle_b.position
            dist = diff.norm()
            min_dist = beetle_a.radius + beetle_b.radius
            
            if dist < min_dist:
                # COLLISION DETECTED
                collision_normal = diff.normalized()
                overlap = min_dist - dist
                
                # Separate beetles (push apart)
                separation = collision_normal * overlap * 0.5
                beetle_a.position += separation
                beetle_b.position -= separation
                
                # Calculate impact force
                relative_velocity = beetle_a.velocity - beetle_b.velocity
                impact_speed = relative_velocity.dot(collision_normal)
                
                # Apply impulse (momentum transfer)
                mass_a = beetle_a.mass
                mass_b = beetle_b.mass
                impulse_magnitude = (2.0 * impact_speed) / (mass_a + mass_b)
                
                impulse = collision_normal * impulse_magnitude
                
                beetle_a.velocity -= impulse * mass_b
                beetle_b.velocity += impulse * mass_a
                
                # Store collision data for animations/effects
                collision_force = impulse.norm() * 100
                beetle_a.last_collision_force = collision_force
                beetle_b.last_collision_force = collision_force
                beetle_a.last_collision_time = time
                beetle_b.last_collision_time = time
                
                # Trigger effects if strong hit
                if collision_force > 50:
                    impact_position = (beetle_a.position + beetle_b.position) * 0.5
                    spawn_impact_effect(impact_position, collision_force)
```

**Charge Attack Mechanics:**

```python
@ti.kernel
def apply_charge_attack(beetle_id: int):
    """Special charge move - builds up then releases"""
    
    beetle = beetles[beetle_id]
    
    if beetle.is_charging and beetle.stamina > 20:
        # Get charge direction
        forward = get_forward_vector(beetle.rotation)
        
        # Apply massive impulse
        charge_force = forward * beetle.horn_power * 5.0
        apply_impulse(beetle, charge_force)
        
        # Deplete stamina
        beetle.stamina -= 20
        
        # Set charge state (used by animation system)
        beetle.charge_start_time = time
        beetle.charge_duration = 0.5  # Half second charge
        
        # Visual indicator
        beetle.horn_glow_intensity = 1.0
```

**Arena Boundary Push:**

```python
@ti.func
def apply_arena_pressure(beetle_id: int):
    """Push beetles away from edge (soft boundary)"""
    
    beetle = beetles[beetle_id]
    
    distance_to_center = (beetle.position - arena.center).norm()
    distance_to_edge = arena.radius - distance_to_center
    
    # Danger zone (within 30 units of edge)
    if distance_to_edge < 30:
        # Calculate push force (stronger near edge)
        push_strength = (30 - distance_to_edge) / 30  # 0 to 1
        push_direction = (arena.center - beetle.position).normalized()
        
        # Apply gentle push toward center
        push_force = push_direction * push_strength * 50.0
        apply_force(beetle, push_force)
        
        # Set danger state (visual warning)
        beetle.in_danger_zone = True
        beetle.danger_intensity = push_strength
    else:
        beetle.in_danger_zone = False
```

---

### Procedural Animation System

**The Key Principle:** Animations react to physics state, not controlled by AI.

**Animation State Machine:**

```python
@ti.data_oriented
class BeetleAnimator:
    """Handles all beetle visual animations based on physics"""
    
    def __init__(self):
        # Animation state per beetle
        self.leg_phases = ti.field(float, shape=(MAX_BEETLES, 6))  # 6 legs
        self.pincer_angles = ti.field(float, shape=(MAX_BEETLES, 2))  # 2 pincers
        self.body_tilt = ti.Vector.field(3, float, shape=MAX_BEETLES)
        self.horn_extension = ti.field(float, shape=MAX_BEETLES)
    
    @ti.kernel
    def update_animations(self, dt: float):
        """Update all animation states based on beetle physics"""
        
        for beetle_id in range(num_active_beetles):
            self.animate_legs(beetle_id, dt)
            self.animate_pincers(beetle_id, dt)
            self.animate_body(beetle_id, dt)
            self.animate_horn(beetle_id, dt)
```

**Leg Animation (Walking):**

```python
@ti.func
def animate_legs(self, beetle_id: int, dt: float):
    """Legs wiggle based on movement speed"""
    
    beetle = beetles[beetle_id]
    speed = beetle.velocity.norm()
    
    if speed > 2.0:  # Beetle is moving
        # Walking animation
        walk_frequency = speed * 0.3  # Faster = faster leg movement
        
        for leg_idx in range(6):
            # Each leg has phase offset (alternating gait)
            phase_offset = leg_idx * (PI / 3)
            phase = time * walk_frequency + phase_offset
            
            # Leg position oscillates
            leg_lift = ti.sin(phase) * 3.0  # Up/down motion
            leg_reach = ti.cos(phase) * 2.0  # Forward/back motion
            
            # Store leg offset (applied during rendering)
            self.leg_phases[beetle_id, leg_idx] = phase
            
            # Apply to leg transform
            beetle.leg_offsets[leg_idx].z = leg_lift
            beetle.leg_offsets[leg_idx].x = leg_reach
    
    else:  # Beetle is stationary
        # Idle breathing animation
        for leg_idx in range(6):
            idle_phase = ti.sin(time * 2.0 + leg_idx * 0.5) * 0.5
            beetle.leg_offsets[leg_idx].z = idle_phase
```

**Pincer Animation (Combat State):**

```python
@ti.func
def animate_pincers(self, beetle_id: int, dt: float):
    """Pincers react to combat actions"""
    
    beetle = beetles[beetle_id]
    time_since_collision = time - beetle.last_collision_time
    time_since_charge = time - beetle.charge_start_time
    
    # STATE 1: Just hit something (pincers SNAP closed)
    if time_since_collision < 0.2:
        target_angle = 0.0  # Closed
        lerp_speed = 0.8  # Fast snap
        
        # Add impact shake to pincers
        shake = ti.sin(time_since_collision * 50) * 5.0
        beetle.pincer_shake = shake
    
    # STATE 2: Charging (pincers WIDE open, threatening)
    elif beetle.is_charging or time_since_charge < beetle.charge_duration:
        charge_progress = time_since_charge / beetle.charge_duration
        target_angle = 60.0 * (1.0 - charge_progress)  # Open -> close during charge
        lerp_speed = 0.3
        
        # Pincers glow during charge
        beetle.pincer_glow = 1.0 - charge_progress
    
    # STATE 3: Defensive stance (pincers half-closed, guarded)
    elif beetle.is_defensive:
        target_angle = 15.0  # Slightly open
        lerp_speed = 0.2  # Slow, steady
    
    # STATE 4: Idle (gentle breathing motion)
    else:
        breath = ti.sin(time * 3.0) * 0.5 + 0.5  # 0 to 1
        target_angle = 20.0 + breath * 10.0  # 20-30 degrees
        lerp_speed = 0.1
    
    # Smooth interpolation to target
    for pincer_idx in range(2):
        current = self.pincer_angles[beetle_id, pincer_idx]
        self.pincer_angles[beetle_id, pincer_idx] = lerp(
            current, 
            target_angle, 
            lerp_speed
        )
```

**Body Animation (Impact & Movement):**

```python
@ti.func
def animate_body(self, beetle_id: int, dt: float):
    """Body tilts and reacts to forces"""
    
    beetle = beetles[beetle_id]
    
    # Tilt based on acceleration (lean into movement)
    acceleration = (beetle.velocity - beetle.previous_velocity) / dt
    
    # Convert acceleration to tilt angles
    tilt_x = ti.clamp(acceleration.x * 0.05, -15.0, 15.0)  # Side tilt
    tilt_y = ti.clamp(acceleration.y * 0.05, -15.0, 15.0)  # Forward/back
    
    # Smooth the tilt
    target_tilt = ti.Vector([tilt_x, tilt_y, 0.0])
    self.body_tilt[beetle_id] = lerp(
        self.body_tilt[beetle_id],
        target_tilt,
        0.3
    )
    
    # Impact recoil (when hit hard)
    time_since_hit = time - beetle.last_collision_time
    if time_since_hit < 0.3:
        # Recoil shake
        recoil_intensity = beetle.last_collision_force / 100.0
        shake = ti.sin(time_since_hit * 30) * recoil_intensity * 5.0
        self.body_tilt[beetle_id].z += shake
```

**Horn/Weapon Animation:**

```python
@ti.func
def animate_horn(self, beetle_id: int, dt: float):
    """Horn extends during charge, retracts after"""
    
    beetle = beetles[beetle_id]
    time_since_charge = time - beetle.charge_start_time
    
    if time_since_charge < beetle.charge_duration:
        # Charging - horn extends forward
        charge_progress = time_since_charge / beetle.charge_duration
        self.horn_extension[beetle_id] = charge_progress * 1.5  # Extend 50%
    else:
        # Retract back to normal
        self.horn_extension[beetle_id] = lerp(
            self.horn_extension[beetle_id],
            0.0,  # Normal position
            0.2   # Smooth retraction
        )
```

---

### Struggling Animation (Special Case)

When a beetle is pushing hard but not moving (stuck/struggling):

```python
@ti.func
def detect_and_animate_struggle(self, beetle_id: int):
    """Special animation when beetle is pushing but stuck"""
    
    beetle = beetles[beetle_id]
    
    # Calculate "effort" vs "result"
    effort = beetle.applied_force.norm()  # How hard trying
    result = beetle.velocity.norm()       # How much moving
    
    # If high effort but low result = STRUGGLING
    if effort > 50 and result < 5:
        struggle_intensity = effort / 100.0
        
        # Legs go CRAZY (frantic movement)
        for leg_idx in range(6):
            frantic_phase = time * 10.0 + leg_idx * 0.3  # Very fast
            beetle.leg_offsets[leg_idx].z = ti.sin(frantic_phase) * 5.0 * struggle_intensity
            beetle.leg_offsets[leg_idx].x = ti.cos(frantic_phase * 1.3) * 3.0
        
        # Body rocks side to side
        rock = ti.sin(time * 8.0) * struggle_intensity * 10.0
        beetle.body_tilt.x += rock
        
        # Pincers flail open/closed rapidly
        flail = ti.sin(time * 15.0) * 0.5 + 0.5
        beetle.pincer_angles[0] = flail * 45.0
        beetle.pincer_angles[1] = (1.0 - flail) * 45.0
        
        # Particle effects (dust/sparks from legs)
        if ti.random() < 0.3:  # 30% chance per frame
            spawn_struggle_particles(beetle.position, struggle_intensity)
```

---

### Visual Effects Integration

**Impact Particles:**

```python
@ti.func
def spawn_impact_effect(position: ti.math.vec3, force: float):
    """Create particle burst on collision"""
    
    num_particles = int(ti.min(force / 5, 50))  # Scale with impact
    
    for i in range(num_particles):
        # Random spray pattern
        angle = ti.random() * PI * 2
        speed = ti.random() * 100 + 50
        
        particle_velocity = ti.Vector([
            ti.cos(angle) * speed,
            ti.sin(angle) * speed,
            ti.random() * 50  # Upward component
        ])
        
        # Spawn particle
        spawn_particle(
            position=position,
            velocity=particle_velocity,
            color=ti.Vector([1.0, 0.8, 0.3]),  # Orange/yellow
            lifetime=1.0,
            size=2.0
        )
```

**Charge Attack Glow:**

```python
@ti.kernel
def render_charge_glow():
    """Visual effect for charging beetles"""
    
    for beetle_id in range(num_active_beetles):
        beetle = beetles[beetle_id]
        
        if beetle.horn_glow_intensity > 0.1:
            # Horn tip position
            forward = get_forward_vector(beetle.rotation)
            horn_tip = beetle.position + forward * beetle.horn_length
            
            # Pulsing glow
            pulse = ti.sin(time * 15.0) * 0.3 + 0.7
            glow_size = 8.0 * beetle.horn_glow_intensity * pulse
            
            # Render glow sphere
            render_glow_sphere(
                position=horn_tip,
                radius=glow_size,
                color=ti.Vector([1.0, 1.0, 0.5]),
                alpha=beetle.horn_glow_intensity * 0.7
            )
            
            # Trail particles
            if ti.random() < 0.5:
                spawn_particle(
                    position=horn_tip,
                    velocity=-forward * 30,
                    color=ti.Vector([1.0, 0.9, 0.3]),
                    lifetime=0.3,
                    size=1.5
                )
            
            # Decay glow over time
            beetle.horn_glow_intensity *= 0.95
```

**Danger Zone Warning:**

```python
@ti.kernel
def render_danger_warnings():
    """Visual feedback when beetle near edge"""
    
    for beetle_id in range(num_active_beetles):
        beetle = beetles[beetle_id]
        
        if beetle.in_danger_zone:
            # Red ring around beetle
            ring_radius = beetle.radius * 1.5
            ring_alpha = beetle.danger_intensity * 0.6
            
            render_ring(
                position=beetle.position,
                radius=ring_radius,
                color=ti.Vector([1.0, 0.0, 0.0]),
                alpha=ring_alpha,
                thickness=2.0
            )
            
            # Pulsing effect
            if ti.sin(time * 8.0) > 0:
                # Warning particles
                spawn_warning_particle(beetle.position)
```

---

### Rendering Pipeline

**How everything comes together each frame:**

```python
def render_frame():
    """Main render loop - called at 60fps"""
    
    # 1. Update physics
    physics_engine.step(dt=1/60)
    
    # 2. Update animations based on new physics state
    animator.update_animations(dt=1/60)
    
    # 3. Render voxel models with animated transforms
    for beetle_id in range(num_active_beetles):
        beetle = beetles[beetle_id]
        
        # Get animation state
        body_tilt = animator.body_tilt[beetle_id]
        horn_extension = animator.horn_extension[beetle_id]
        
        # Build transform matrix
        transform = create_transform(
            position=beetle.position,
            rotation=beetle.rotation + body_tilt,  # Apply tilt
            scale=beetle.size
        )
        
        # Render body
        render_voxel_model(beetle.body_voxels, transform)
        
        # Render animated legs
        for leg_idx in range(6):
            leg_offset = beetle.leg_offsets[leg_idx]
            leg_transform = transform @ create_leg_transform(leg_idx, leg_offset)
            render_voxel_model(beetle.leg_voxels, leg_transform)
        
        # Render animated pincers
        for pincer_idx in range(2):
            pincer_angle = animator.pincer_angles[beetle_id, pincer_idx]
            pincer_transform = transform @ create_pincer_transform(
                pincer_idx, 
                pincer_angle,
                horn_extension
            )
            render_voxel_model(beetle.pincer_voxels, pincer_transform)
    
    # 4. Render particles
    particle_system.render()
    
    # 5. Render effects (glows, warnings)
    render_charge_glow()
    render_danger_warnings()
    
    # 6. Render UI overlay
    render_ui()
    
    # 7. Display
    canvas.show()
```

---

### Vibe Coding the Animation System

**Prompt to AI (Phase 1.5 - After basic physics works):**

```
Add procedural animation system:

1. Leg Animation:
   - 6 legs per beetle
   - Wiggle when moving (speed determines frequency)
   - Idle breathing motion when stationary
   - Frantic thrashing when stuck (high force, low velocity)

2. Pincer Animation:
   - 2 pincers that open/close
   - SNAP closed on collision (fast, 0.2 sec)
   - Wide open during charge (60 degrees)
   - Gentle idle motion (20-30 degrees, breathing)

3. Body Animation:
   - Tilt in direction of acceleration
   - Recoil shake when hit (proportional to impact force)

4. Horn Animation:
   - Extend 50% during charge
   - Glow effect while charging (pulsing yellow)
   - Retract smoothly after charge

All animations should be procedural - no keyframes.
Use lerp for smooth transitions.
Animations react to physics state (beetle.velocity, beetle.is_charging, etc).

Show me beetle with full animation walking in a circle, then charging.
```

**Iteration Example:**

You watch the result and notice:

```
Issues:
1. Legs look robotic - all move in sync. Add phase offset so they 
   alternate (tripod gait - legs 0,2,4 vs 1,3,5)

2. Pincer snap is too slow - needs to feel like a CRUNCH. 
   Change lerp speed from 0.2 to 0.8 on collision.

3. Body tilt is too extreme - beetle looks like it's falling over.
   Reduce tilt multiplier from 0.1 to 0.05, clamp to ¬±15 degrees.

4. Charge glow is barely visible. Increase alpha from 0.3 to 0.7,
   add trail particles behind the horn tip.

Keep the struggle animation - that looks hilarious!
```

AI refines based on your feedback. Repeat until animations feel alive.

---

## Development Process: The Vibe Coding Loop

### Phase Structure

Each phase follows the same cycle:

```
1. DEFINE (5% of time)
   ‚Üì Tell AI what we want
   
2. GENERATE (30% of time)  
   ‚Üì AI writes initial implementation
   
3. PLAYTEST (40% of time)
   ‚Üì Run it, feel it, find issues
   
4. ITERATE (25% of time)
   ‚Üì Describe problems, AI refines
   
5. LOCK ‚úì
   ‚Üì This part is done, move on
```

### Example: Phase 1 - Core Physics

**Day 1: Define & Generate**

**Your prompt to AI:**
```
Create a Taichi physics simulation with:
- Circular arena, 200 unit radius
- Two voxel beetles (simple boxes for now)
- Physics forces: movement, collision, rotation
- Camera: top-down, can orbit
- Manual WASD controls for beetle 1
- Arrow keys for beetle 2
- Ring-out detection (falls off = lose)
- Run at 60fps

Make it so I can immediately run it and push beetles around.
```

**AI generates:**
- `physics_engine.py` - Core Taichi simulation
- `beetle.py` - Beetle entity with voxel data
- `arena.py` - Arena boundaries and collision
- `main.py` - Game loop with input handling
- `requirements.txt` - Dependencies

**Output:** ~500 lines of code, immediately runnable

---

**Day 2-3: Playtest & Iterate**

**You run it and feel:**
- ‚ùå Beetles slide too much (too slippery)
- ‚ùå Pushing feels weak (not satisfying)
- ‚úÖ Ring-outs work great!
- ‚ùå Camera is too close

**Your feedback to AI:**
```
Issues found:
1. Friction is too low - beetles slide like ice hockey pucks. 
   Increase friction to 0.7, they should stop quickly when not moving.

2. Collision forces feel wimpy. When beetles hit, I want a CRUNCH.
   Multiply collision impulse by 2x, add screen shake on impacts > 100 force.

3. Camera is claustrophobic. Pull back 50%, add smooth follow.

Keep the ring-out behavior, that's perfect.
```

**AI refines the code**, you test again. Repeat until it **feels right**.

---

**Day 4: Lock It**

When pushing beetles around is satisfying and you can spend 5 minutes just playing with physics, **lock Phase 1**.

Create a git commit: `‚úÖ Phase 1 Complete - Physics Feel Good`

**Key Insight:** We're not moving to Phase 2 because we hit some arbitrary deadline. We're moving on because **the physics feel fun**. This is crucial - if the foundation isn't fun, nothing built on top will save it.

---

### Phase 2: AI Brains (Week 2-3)

**Define & Generate:**

```
Add JAX neural networks:
- Input: 12 sensors (position, opponent distance, velocity, etc)
- Output: 5 actions (move, rotate, charge, defend)
- Brain structure: 12 ‚Üí 24 ‚Üí 5 (tanh activations)
- Connect sensors to physics engine
- Connect outputs to force application
- Create 50 random brains
- Run a fight with random brains controlling both beetles

I should see beetles moving (badly) on their own.
```

**AI generates neural net brain system.**

**Playtest:**
- Watch beetles flail around randomly (expected)
- Verify sensors are getting reasonable values
- Verify actions affect physics correctly

**Iterate on Training:**

```
Create genetic algorithm:
- Fitness = survival time + center position + damage dealt
- Selection: top 20% elite
- Crossover: mix parent weights
- Mutation: 10% noise
- Run 20 generations
- Show best fitness each generation

Train against a stationary opponent first (easy baseline).
```

**Watch training happen.** If after 20 generations beetles still fall off edges immediately, fitness function is wrong. Iterate:

```
Beetles aren't learning to stay in arena. Increase fitness reward 
for staying centered (currently 50, try 200). Also add penalty 
for getting near edge (-100 per second in danger zone).
```

**Keep iterating until:**
- Beetles learn to avoid edges consistently
- Some charging behavior emerges
- 2-3 distinct "personalities" appear (rusher, circler, defensive)

**Lock Phase 2** when watching AI vs AI fights is interesting for 30+ seconds.

---

### Phase 3: Betting System (Week 3-4)

**Define & Generate:**

```
Create game loop:
1. Generate roster of 12 beetles with random stats
2. Show fight card (6 matchups)
3. For each fight:
   - Run 60-second training simulation (fast, no render)
   - Generate behavioral insights from training
   - Calculate odds based on stats + training
   - Show betting interface
   - Player places bet
   - Run actual fight (rendered, 30 seconds)
   - Show results, update bankroll
4. Repeat

Starting bankroll: 1000 chips
Betting interface: simple list with odds and bet amount slider
```

**Playtest:**
- Do training insights actually predict wins?
- Can you develop a "feel" for good bets?
- Is the loop engaging for 15 minutes?

**Iterate on game feel:**

```
Problems:
1. Training cam is too fast - I can't read insights before betting.
   Show insights for 20 seconds before betting starts.

2. All beetles feel the same. Generate more stat variety:
   - Size: 15-25 (currently 20-20, no variance)
   - Power: 100-300 (currently locked at 200)
   - Stamina: 80-120 (currently 100 for all)

3. Odds seem random. Make stat advantages more visible:
   - Show size comparison visually (bigger beetle = bigger model)
   - Show power as horn length
   - Color-code high stamina beetles (green tint)

4. Winning feels hollow. Add celebration particles when you win bet.
```

**Keep iterating until:**
- You can identify "good" bets from training cams
- Winning a bet feels rewarding
- Going on a win streak feels achievable through skill
- Losing a bet makes you think "I should've noticed X"

**Lock Phase 3** when you want to keep playing to grow your bankroll.

---

## Effective Prompting Strategies

### The Incremental Approach

**Bad Prompt:**
```
Make a complete betting game with AI beetles
```
*Too vague, AI will hallucinate requirements*

**Good Prompt:**
```
Create just the circular arena with boundary detection.
- Taichi GPU-accelerated
- 200 unit radius
- Function: is_inside(position) -> bool
- Function: distance_to_edge(position) -> float
- Visual: draw the arena as a voxel circle
- Test: print distance to edge for a point at (150, 0, 0)
```
*Specific, testable, incremental*

### The Feedback Loop Pattern

```
[AI generates code]
   ‚Üì
[You run it]
   ‚Üì
[You describe what you SEE and FEEL]
   ‚Üì
[AI refines based on your experience]
   ‚Üì
[Repeat until it feels right]
```

**Example Feedback:**
```
Good:
"When beetles collide, I barely notice. The impact should be 
more dramatic - bigger particles, screen shake, maybe slow-mo 
for 0.2 seconds on hard hits (force > 200)."

Bad:
"Make collisions better."
```

### The Parameter Tuning Pattern

When something feels wrong but you're not sure what to change:

```
Prompt AI:
"The physics feel off. Create a debug UI showing:
- Current friction value
- Current mass for each beetle  
- Current collision impulse multiplier
- Buttons to increase/decrease each by 10%

I'll tune these live until it feels right, then tell you 
the final values."
```

AI generates a live parameter tweaker. You play with sliders until it feels good. Then lock those values.

### The Procedural Art Pattern

```
"Create a function: generate_beetle_voxels(size, horn_type, color_theme)

Horn types:
- 'thick_short': stubby horn, max size/3 length
- 'long_thin': needle horn, max size*1.5 length  
- 'wide_flat': shovel-shaped, size width

Color themes:
- 'fire': red/orange gradient
- 'ice': blue/white gradient
- 'earth': brown/green gradient

Return 3D numpy array of voxel colors.
Show me examples of all 9 combinations."
```

AI generates procedural art code. You iterate on the algorithm until beetles look cool, never touching 3D modeling software.

---

## Handling Common Vibe Coding Challenges

### Challenge: "AI generated code that doesn't run"

**Solution:** Incremental verification

```
"Before writing the full physics system, create a minimal test:
1. Initialize Taichi
2. Create a single voxel at (0,0,0)
3. Render it
4. Show me the complete runnable code including imports

Once this works, we'll add movement."
```

Build in tiny, testable chunks.

### Challenge: "The game feels boring"

**Solution:** Playtest with fresh eyes

Take a break. Come back. Play for 5 minutes. Note **the exact moment** you get bored.

```
"I played for 3 minutes. The first 90 seconds were fun, but then 
I realized I'm just watching RNG. The beetles' strategies don't 
matter - bigger beetle always wins.

Make size advantage smaller (currently 30% win rate boost, try 15%).
Make training insights more impactful (add 'warm up performance' 
metric that predicts first 10 seconds of fight)."
```

Iterate on **boredom pinch points**, not vague "make it more fun."

### Challenge: "Too many features, losing focus"

**Solution:** The Lock & Defer pattern

When you think of a cool feature mid-development:

```
‚úÖ Lock current work first
üìù Add to 'Phase 5+' section
üö´ Do NOT implement now
```

Example:
```
"Ooh, what if beetles could evolve new abilities between sessions?"

‚Üí Great idea! Added to Phase 5. 
  First, finish Phase 3 (basic betting must work).
```

### Challenge: "Physics/AI parameters are a mystery"

**Solution:** Parameter archaeology

```
"Create a training logger that records:
- Every beetle's fitness score
- Final fitness function breakdown (survival: X, positioning: Y, aggression: Z)
- Winning percentage by beetle size
- Winning percentage by training aggression level

Run 100 fights, output CSV.
I'll analyze what actually correlates with winning."
```

Use data to guide tuning instead of guessing.

### Challenge: "Animations look wrong"

**Solution:** Record and describe

```
"I recorded 10 seconds of gameplay. Here's what looks off:

0:02 - Beetle charges, but legs keep walking animation (should be 
       tucked or stretched out during charge)
0:05 - Collision happens, pincers snap shut BUT then immediately 
       open again (should stay closed for 0.5 sec)
0:08 - Beetle struggling against wall, but body isn't tilting 
       (should lean INTO the direction it's pushing)

Fix these three timing/state issues."
```

Specific observations ‚Üí targeted fixes.

---

## Critical Success Factors

### 1. The Feel Test

Every phase must pass: **"Can I show this to a friend and they immediately understand what's fun?"**

- Phase 1: Friend can push beetles around and laugh when one falls off
- Phase 2: Friend watches AI fight and says "oh that beetle is more aggressive"
- Phase 3: Friend places a bet, watches fight, reacts to outcome

If they look confused or bored, **that phase isn't done**.

### 2. The 5-Minute Rule

At any point in development, you should be able to:
- Run the game
- Understand current state in < 30 seconds
- Test a specific thing
- Give AI feedback

If you can't do this, your code is too complex. Ask AI to simplify.

### 3. The Dopamine Check

Playtest and track **when you feel excitement**:

- ‚úÖ "Oh shit, that beetle almost fell off!"
- ‚úÖ "Wait, this underdog is actually winning!"
- ‚úÖ "I KNEW that aggressive beetle would choke!"
- ‚ùå *[numbly watching beetles move around]*

Maximize ‚úÖ moments, eliminate ‚ùå moments.

### 4. The Iteration Budget

Each feature gets **max 3 iteration cycles** before you decide:
- ‚úÖ Lock it (good enough)
- üîÑ Pivot approach (fundamentally rethink)
- üóëÔ∏è Cut it (not essential)

Don't get stuck in refinement hell on non-core features.

---

## Week-by-Week Milestones

**Week 1:** Physics feels satisfying, animations look alive  
**Week 2:** AI fights are interesting to watch  
**Week 3:** Betting loop is functional  
**Week 4:** Training cams provide real edge  
**Week 5:** Visual polish, juice, particles  
**Week 6:** Sound, UI, tutorial  
**Week 7:** Bug fixes, balance  
**Week 8:** Ship to itch.io

Each week **must produce a playable build**. No "it's not ready to run yet" allowed.

---

## The Vibe Coding Mindset

**You are the designer.** AI is the implementation engine.

Your job:
- Define what "fun" feels like
- Spot when something feels wrong
- Describe the player experience you want

AI's job:
- Turn descriptions into code
- Handle technical details
- Iterate quickly on your feedback

**Never accept "good enough" on core feel.** If pushing beetles doesn't feel satisfying in Week 1, spending 5 more weeks on top of bad physics is wasted effort.

**Always accept "good enough" on polish.** If particle effects are 80% there, move on. You can juice it later.

The magic happens in the **iteration loop**. Fast cycles of generate ‚Üí test ‚Üí refine ‚Üí repeat. That's vibe coding.

---

## Animation-Specific Vibe Coding Tips

### Testing Animations in Isolation

```
"Create an animation test scene:
- Single beetle in center of screen
- Buttons to trigger states:
  - Walk forward
  - Charge attack
  - Take hit (collision)
  - Struggle (high force, no movement)
  - Idle
- Slow motion toggle (0.25x speed)
- Show animation state debug text

I want to see each animation clearly to tune timing."
```

### The "Onion Skin" Debug View

```
"Add debug rendering mode that shows:
- Beetle position trail (last 30 frames)
- Leg position trails
- Pincer angle history (line graph)
- Force vectors (arrows showing applied forces)

This helps me see if animations are responsive to physics."
```

### The Comparison Test

```
"Create split-screen mode:
- Left: beetle with OLD animation parameters
- Right: beetle with NEW animation parameters
- Both do identical movements
- I can compare side-by-side to see which feels better"
```

---

## Ready to Start?

First prompt to send AI:

```
Let's build the foundation. Create a minimal Taichi physics sandbox:

- Circular arena (200 radius)
- One voxel beetle (simple rectangular prism for now, 20x10x10 voxels)
- WASD to apply forces (forward/back/left/right)
- Physics: friction, collision with arena boundary
- Camera: top-down, centered on beetle
- Press R to reset beetle to center
- Press ESC to quit

Make it immediately runnable. Include all imports and initialization.
I want to feel what it's like to push a beetle around in 5 minutes.
```

Let's vibe code this thing into existence.
